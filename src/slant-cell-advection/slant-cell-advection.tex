\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{xcolor}

\title{Multidimensional Cubic Upwind-Biased Advection of Slanted Cell Grids}

\newcommand{\TODO}[1]{\textcolor{purple}{TODO: \emph{#1}}}
\begin{document}
\maketitle
\begin{figure}
	\centering
	\includegraphics{../fig-grid-generation/fig-grid-generation.pdf}
	%
	\caption{Illustration of a slanted cell grid (a) before, and (b) after construction.
	The terrain surface, denoted by a heavy dotted line, intersects a uniform rectangular grid comprising four cells, $c_1$, $c_2$, $c_3$ and $c_4$.  The cell vertices, marked by open circles, are moved upwards to the points at which the terrain intersects vertical cell edges, marked by open circles.  Cells that have no volume are removed.  Where a cell has two vertices occupying the same point, the zero-length edge that joins those vertices is removed.  In this illustration, cell $c_4$ is removed because it has no volume, and the zero-length edge at point $p$ is removed to create a triangular cell, $c_3$.}
	\label{fig:grid-generation}
\end{figure}

A tracer with density $\phi$ is advected in flux form
\begin{align}
\partial \phi / \partial t + \nabla \cdot \left( \mathbf{u} \phi \right) = 0
\end{align}
where $\mathbf{u}$ is the velocity field.  Using the notation that, for a field $\psi$, $\psi_f$ denotes the value of $\psi$ at face $f$.  $\psi_c$ denotes the value at the centroid of cell $c$, and $\psi_F$ is an interpolation onto a face from surrounding cell centre values.  The divergence term is discretised using Gauss' divergence theorem:
\begin{align}
	\nabla \cdot \left( \mathbf{u} \phi \right) \approx \frac{1}{\mathcal{V}} \sum_{f \in c} \phi_F \mathbf{u}_f \cdot \mathbf{S}_f
\end{align}
where $\mathcal{V}$ is the cell volume, $f \in c$ denotes the faces of the cell, and $\mathbf{S}_f$ is the outward-pointing normal vector for face $f$ with a magnitude equal to the face area.

\begin{figure}
	\centering
	\includegraphics{../fig-upwind-stencil/fig-upwind-stencil.pdf}
	%
	\caption{\TODO{}}
	\label{fig:upwind-stencil}
\end{figure}

The value of $\phi_F$ is interpolated using a least squares fit of cell centre values from an upwind-biased stencil (figure~\ref{fig:upwind-stencil}).  In two dimensions, the values are fitted to the polynomial:
\begin{align}
	\phi = a + bx + cy + dx^2 + exy + dy^2 + gx^3 + h x^2 y + i x y^2
\end{align}
where $x$ is in the direction of $\mathbf{S}_f$ and $y$ is perpendicular to $x$.  The term involving $y^3$ is omitted.

The upwind-biased stencil is constructed by finding the opposing faces for a given face, $f$, belonging to a cell, $c$.  Defining $G$ to be the set of other faces in cell $c$, we calculate the `opposedness' between faces $f$ and $g \in G$, defined as
\begin{align}
	\mathrm{Opp}(f, g) \equiv - \frac{\mathbf{S}_f \cdot \mathbf{S}_g}{|\mathbf{S}_f|^2}
\end{align}
where $\mathbf{S}_f$ and $\mathbf{S}_g$ are the surface normal vectors pointing outward from cell $c$ for faces $f$ and $g$ respectively.  Now, let $\mathrm{OF}$ be the set of faces opposing face $f$, which is defined as
\begin{align}
	\mathrm{OF} \equiv \{ g : \max(\mathrm{Opp}(f, g)) \} \cup \{ g : \mathrm{Opp}(f, g) \geq 0.5 \}
\end{align}
\TODO{can the opposed face be a boundary face?  I think this is desirable in order to find the upwind cell centre...}
The stencil includes cells adjacent to the faces in $\mathrm{OF}$, and their vertex neighbours.

\begin{figure}
	\centering
	\includegraphics{../fig-double-upwind-stencil/fig-double-upwind-stencil.pdf}
	%
	\caption{\TODO{}}
	\label{fig:double-upwind-stencil}
\end{figure}

Figure~\ref{fig:double-upwind-stencil} illustrates stencil construction for face $f$ and cell $c$.  

% cell weightings
% polynomial term weightings
% SVD provides us with  

% procedure:
% for each face and for both orientations:
% 1. find stencil
% 2. are we pureUpwind? compare upwind/downwind vectors
% 3. give upwind cell weighting of 1000
% 4. if !pureUpwind, also give downwind cell weighting of 1000
% 5. *1000 for 'a' and 'b' terms
% (rescale and reorientate, probably not crucial to mention)
% iterate up to 8 times (and at least once)
%   SVD for "B"
%   coeffsi[i] = 1000 * weight[i] * VSinvUt[0][i]
%   test for good fit criteria:
%   - mag(upwind cell weight correction) < linearLimitFactor
%   - upwind weight > downwind weight
%   - upwind weight > sum(other positive weights)
%   - max(weight) < 1
%   if good fit criteria are not met:
%   - upwind input weight *= 10
%   - if not pure upwind, remove downwind 1000 weighting (in wts and in B matrix) on the first iteration
%   - multiply all upwind weights by 10 in the SVD matrix
%   - multiply a and b polynomial terms by 10 for all cells
% finally, if good fit criteria are still not met, revert to standard 'upwind': phi_F \approx phi_U

% how do we find the contributing cells?
% what do we do if there aren't enough cells?
% need to define terminology for "weights":
% - weights fed into SVD
% - weights that come out of SVD

% linearLimitFactor documented in UpwindCorrFitScheme.H, is specified in fvSchemes, we have it set to 3

\end{document}
